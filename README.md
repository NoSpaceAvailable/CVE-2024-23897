![jenkins](https://github.com/user-attachments/assets/536d6be3-1bd5-4463-8b3a-7eb22715d1ad)

Jenkins là một Java opensource dùng để thực hiện chức năng tích hợp liên tục, triển khai liên tục (CI/CD – Continuous Integration/Continuous Delivery) và xây dựng các tác vụ tự động hóa. Nó đóng vai trò như một web server tự động thực hiện các tác vụ build, test. Đại khái thì khi lập trình viên tích hợp code của mình vào dự án thì Jenkins sẽ tự động build và chạy test, nếu không có lỗi gì xảy ra thì sẽ đưa code vào triển khai. Điều này làm cho việc phát triển các ứng dụng nhanh chóng hơn.

## Jenkins Access Control
Mặc định, nếu Jenkins được cài ở dạng recommended (được cài thêm các extension phổ biến) thì một webapp Jenkins sẽ có 2 loại user:
  * anonymous user
  * authenticated user, có quyền hạn như admin
Và 4 loại permission:
  * anyone can do anything: cho phép bất kì user nào kể trên thực hiện bất kì thay đổi với project
  * logged-in users can do anything: cho phép những user đã đăng nhập thực hiện thay đổi lên project
  * legacy mode: chỉ người dùng được gán role "admin" được phép thay đổi project, còn lại đều chỉ được cấp read access
  * Matrix-based security: mỗi người dùng được cấu hình để có vai trò cụ thể (như bảng). Vai trò này có tác dụng ở tất cả project (account scope)
    ![image](https://github.com/user-attachments/assets/8c261d9d-c729-436d-96de-20935ce88cba)
  * Project-based security: cũng như bảng trên, nhưng người dùng được cấu hình quyền hạn dựa trên project (project scope)
Còn nếu không cài ở dạng recommended thì có thể Jenkins sẽ làm giảm đi số lượng permissions xuống, nhưhg vẫn giữ nguyên 2 loại users như trên.

Ngoài ra, Jenkins còn cho phép cấu hình quyền hạn của anonymous user bằng cách cấp thêm read access:
    ![image](https://github.com/user-attachments/assets/345bd590-df70-4933-a715-11582731aabc)

Tuy nhiên, với phiên bản Jenkins từ 2.441 trở xuống (hoặc 2.426.2 LTS trở xuống), việc có cấp quyền read cho anonymous user hay không trở nên vô nghĩa khi mà CVE-2024-23897 được phát hiện.

## CVE-2024-23897 
- Lỗ hổng này cho phép ngay cả anonymous user cũng có thể đọc được bất kì file nào trong máy chủ, với số lượng hữu hạn kí tự. Cụ thể, nếu một attacker sử dụng command line interface (CLI) để truy cập đến Jenkins và thêm kí tự '@' thì phần sau @ sẽ được xem như là đường dẫn 1 tệp tin, và thông báo lỗi trả về từ Jenkins sẽ tiết lộ một phần nội dung tệp tin đó.
- Ngoài ra, Jenkins có lưu một số secret key ở dạng plaintext, vì thế nếu các key này được dùng cho mục đích như SSH hay là authorization code cho admin account thì có thể dẫn đến RCE.

## Setup
- Để setup thì chỉ cần một file Dockerfile đơn giản như sau:
  ```Dockerfile
  FROM jenkins/jenkins:2.441-jdk17
  
  EXPOSE 8080
  EXPOSE 50000
  ```
- Rồi chạy `Docker build -t jenkins .` là xong. Sau khi build xong, khởi tạo container và vào localhost port 8080:
  ![image](https://github.com/user-attachments/assets/cfa9c8b9-90e0-40b9-879e-98a8909bb275)
  
- Copy paste admin password được log ở trong docker ra xong sẽ đến phần install plugin. Ở đây mình chọn Install suggested plugins:
  ![image](https://github.com/user-attachments/assets/d4360f26-f014-4b46-8a9a-030a660acc19)

- Tạo tài khoản admin. Nếu không thì dùng tài khoản admin default cũng được:
  ![image](https://github.com/user-attachments/assets/49eaf838-4a21-4416-8659-b9b170b2d322)

- Vậy là xong.

## Exploit
- Ở trang chủ của Jenkins chọn Manage Jenkins -> Jenkins CLI
- Tải file `jenkins-cli.jar` về máy. File này dùng để connect đến Jenkins host thông qua CLI
  ![image](https://github.com/user-attachments/assets/91746a17-2d30-444c-9e52-4a37b9bf14b5)

- Khi chạy thử lệnh được cung cấp, ta thấy Jenkins báo lỗi:
  ![image](https://github.com/user-attachments/assets/75876770-c751-432d-a835-4683ec86fa8a)

- Ta thử cung cấp thêm tham số cho lệnh help xem sao:
  ![image](https://github.com/user-attachments/assets/7c372760-8e27-402b-8e3a-5e21f982ad2e)
  => exploit thành công

- Khi đọc Available commands của Jenkins, ta thấy có tới hơn 70 lệnh khác nhau được Jenkins định nghĩa, tuy nhiên hầu hết đều yêu cầu người dùng phải có quyền Read (mặc định được tắt đối với anonymous user). Ví dụ như câu lệnh gọi Groovy shell sau:
  ![image](https://github.com/user-attachments/assets/b6643796-3a46-4b2c-bd1f-4a4034a66101)

- Sau khi tự động hóa việc chạy 70 câu lệnh thì mình nhận thấy có 2 câu lệnh hữu dụng, gồm: `who-am-i` và `help`, cho phép đọc tối đa 3 dòng trong 1 file (đối với anonymous user không có read access:
  ![image](https://github.com/user-attachments/assets/49624167-aab0-489b-b7a1-61a5e69bac0b)
  ![image](https://github.com/user-attachments/assets/a74a9f21-e9a2-42f0-92f8-ae9d49eb0a70)

- Lệnh `who-am-i` chỉ cho phép đọc dòng đầu tiên của tệp, nhưng như vậy là đủ để đọc /proc/self/environ:
  ![image](https://github.com/user-attachments/assets/40f2a6f0-cd92-4b89-9414-29c4866c08cb)

- Ở /var/jenkins_home và /var/jenkins_home/secrets có chứa một directory là secret, chứa khá nhiều key quan trọng trong hệ thống:
  ![image](https://github.com/user-attachments/assets/a1460cb1-c5c5-498d-95b2-4cabef6929b4)

- Theo [document](https://www.jenkins.io/doc/developer/security/secrets/) thì các key này đa số được lưu ở dạng plaintext có thể được dùng trong các việc như mã hóa AES, ...
  ![image](https://github.com/user-attachments/assets/e63d78db-eb39-4c18-83c9-f166fcb29c16)

- Tác động lên hệ thống nếu các key này lộ ra được liệt kê đầy đủ tại [đây](https://www.jenkins.io/security/advisory/2024-01-24/)

- Thử đọc master.key:
  ![image](https://github.com/user-attachments/assets/1bb0baae-dd0e-40fb-9856-9fc985f88232)

- Như vậy, với lỗ hổng này, attacker có thể đọc được khá nhiều tập tin quan trọng bên trong Jenkins server.

- Nếu như anonymous user được cấp read access thì có thể full read một file bất kì. Để full read thì ta dùng lệnh `connect-node` hoặc `reload-jobs`:
  ![image](https://github.com/user-attachments/assets/8f76166f-884e-4315-b074-4cb3ea188423)

## Phân tích lỗ hổng
- Khi compare ver 2.441 với 2.442 thì ta thấy commit chủ yếu xảy ra ở hai file là *CLIRegisterer.java* và *CLICommand.java* [source](https://github.com/jenkinsci/jenkins/compare/jenkins-2.441...jenkins-2.442). Các CLI hander của Jenkins đều được define ở core\src\main\java\hudson\cli
  ![image](https://github.com/user-attachments/assets/4f51c032-f5b5-42e7-9141-d74019ed7294)

- Khi command được user gửi từ CLI đến server thì sẽ được call đến class *CLIRegisterer* xử lí, dưới dạng tham số *args* của hàm main.
- Ở hàm main thì có define một parser thông qua return value của phương thức `bindMethod()`. Phương thức này nhận một `List<MethodBinder>` object làm tham số, với `MethodBinder` là một class dùng để chuyển các cmd line arguments từ user input sang cho thư viện `args4j` parse:
  ![image](https://github.com/user-attachments/assets/2136e229-dc55-41e2-806e-6f502e049b77)

- Ở trong phương thức `bindMethod()`, đầu tiên phương thức `registerOptionHandlers()` dùng để gọi các option handler tương ứng cho từng arg, sau đó nó tạo một `CmdLineParser` object. Các tham số của user sẽ được đưa vào một stack và sau đó tìm ra các method resolver tương ứng. Đến cuối cùng, các method resolver lại được pass sang cho thư viện `args4j` xử lí thông qua class `MethodBinder`:
  ![image](https://github.com/user-attachments/assets/6f9d8c9f-ccee-4198-984a-67bd4ae73a26)

- Sau khi xong phần parse command line arguments thì chương trình bắt đầu parse arguments:
  ![image](https://github.com/user-attachments/assets/7e635a2a-0bdf-494d-9645-dfd212431aaf)

- Tiếp tục trace vào method này, ta thấy nó làm các công việc như sau:
  ![image](https://github.com/user-attachments/assets/10dd19fb-29da-4ea4-9331-dacf9c443cb5)
  * Đầu tiên, method này check xem các tham số có rỗng không. Sau đó, trong khối lệnh if, nó kiểm tra syntax của các arguments qua method `this.parserProperties.getAtSyntax()`
  * Tiếp tục trace lên thuộc tính `this.parserProperties`, ta thấy rằng nó được khởi tạo bằng class method `ParserProperties.defaults()`. Khối lệnh if bên dưới chỉ đơn giản là sort lại các argument, tuy nhiên nó không được thực thi do Jenkins đã instantiate một object CmdLineParser với tham số là null:
    ![image](https://github.com/user-attachments/assets/bcabe0d4-a4b3-4e98-bf89-a46b0aa3d551)
  * Trace vào `ParserProperties.defaults()`, ta thấy rằng method này lại gọi đến constructor của class `ParserProperties`, tuy nhiên thuộc tính `atSyntax` của class này lại được init là true, vì thế khối if của method `parseArgument()` nêu trên luôn được thực thi.
    ![image](https://github.com/user-attachments/assets/9fcf6313-0959-492e-9238-6f1b373de955)
  * Ở if code block trên, args từ user input lại được đưa thẳng vào method `expandAtFiles(args)`. Trong method này, nó kiểm tra xem nếu có tham số nào bắt đầu bằng '@' thì thực hiện đọc file và parse các tham số có trong file đó. Tuy nhiên, nếu không parse được thì throw một error đi kèm với nội dung của file:
    ![image](https://github.com/user-attachments/assets/556ea0d6-0560-41fd-b8ca-0b292fb4e396)
  * Sau khi thực hiện parse arguments từ file xong, chương trình tiếp tục duyệt qua các tham số và parse chúng. Khi này thì nội dung được đọc từ file đã được đưa vào instance cmdLine, sau đó chúng sẽ được kiểm tra xem liệu các tham số có quá dài hay là không hợp lệ không. Để ý rằng nếu một trong hai lỗi đó xảy ra thì chương trình sẽ throw một message đi kèm với các tham số bị lỗi:
  => nếu user input refer đến một file như /etc/passwd thì chắc chắn chương trình sẽ báo lỗi, kèm nội dung của file.

## Tái tạo lỗ hổng trên localhost
- Đầu tiên ta cần install thư viện [args4j](https://args4j.kohsuke.org/).
- Lỗ hổng của Jenkins xảy ra bởi việc sử dụng thư viện mà bỏ sót tính năng của các method. Ta chỉ cần 1 chương trình Java đơn giản như sau để tái tạo lỗ hổng:
  ```Java
  import org.kohsuke.args4j.CmdLineException;

  public class TestFile {
      public static void main(String[] args) throws CmdLineException {
  
          // anonymous user input comes from CLI application
          String[] userInput = {"@file_path_here"};
  
          // the backend initialize a command line parser
          CmdParser parser = new CmdParser();
  
          // the parser parses user input, which includes character '@'
          parser.parse(userInput);
      }
  }
  ```
  - Chạy thử trên local, ta thấy rằng nội dung file đã được leak thông qua error message:
    ![image](https://github.com/user-attachments/assets/ac06044a-2d17-4d40-a6a5-4e2b25b80054)


Related: 
- [CVE-2024-23897](https://www.jenkins.io/security/advisory/2024-01-24/#SECURITY-3314)
- [PoC](https://github.com/h4x0r-dz/CVE-2024-23897)
- [Docker images](https://hub.docker.com/r/jenkins/jenkins)
